-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.3).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Codegen.Pristinum.Par
  ( happyError
  , myLexer
  , pProgram
  , pStmt
  , pListStmt
  , pElifStmt
  , pListElifStmt
  , pExpr
  , pListExpr
  , pBind
  , pBind1
  , pBind2
  , pListBind1
  , pListBind2
  , pType
  ) where

import Prelude

import qualified Codegen.Pristinum.Abs
import Codegen.Pristinum.Lex
import qualified Data.Text

}

%name pProgram Program
%name pStmt Stmt
%name pListStmt ListStmt
%name pElifStmt ElifStmt
%name pListElifStmt ListElifStmt
%name pExpr Expr
%name pListExpr ListExpr
%name pBind Bind
%name pBind1 Bind1
%name pBind2 Bind2
%name pListBind1 ListBind1
%name pListBind2 ListBind2
%name pType Type
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'      { PT _ (TS _ 1)     }
  '!='     { PT _ (TS _ 2)     }
  '%'      { PT _ (TS _ 3)     }
  '&'      { PT _ (TS _ 4)     }
  '&&'     { PT _ (TS _ 5)     }
  '('      { PT _ (TS _ 6)     }
  ')'      { PT _ (TS _ 7)     }
  '*'      { PT _ (TS _ 8)     }
  '**'     { PT _ (TS _ 9)     }
  '+'      { PT _ (TS _ 10)    }
  '++'     { PT _ (TS _ 11)    }
  ','      { PT _ (TS _ 12)    }
  '-'      { PT _ (TS _ 13)    }
  '--'     { PT _ (TS _ 14)    }
  '.'      { PT _ (TS _ 15)    }
  '/'      { PT _ (TS _ 16)    }
  ':'      { PT _ (TS _ 17)    }
  ':='     { PT _ (TS _ 18)    }
  '<'      { PT _ (TS _ 19)    }
  '<<'     { PT _ (TS _ 20)    }
  '<='     { PT _ (TS _ 21)    }
  '='      { PT _ (TS _ 22)    }
  '=='     { PT _ (TS _ 23)    }
  '>'      { PT _ (TS _ 24)    }
  '>='     { PT _ (TS _ 25)    }
  '>>'     { PT _ (TS _ 26)    }
  '@'      { PT _ (TS _ 27)    }
  '^'      { PT _ (TS _ 28)    }
  'bool'   { PT _ (TS _ 29)    }
  'char'   { PT _ (TS _ 30)    }
  'elif'   { PT _ (TS _ 31)    }
  'else'   { PT _ (TS _ 32)    }
  'end'    { PT _ (TS _ 33)    }
  'f32'    { PT _ (TS _ 34)    }
  'f64'    { PT _ (TS _ 35)    }
  'false'  { PT _ (TS _ 36)    }
  'func'   { PT _ (TS _ 37)    }
  'i16'    { PT _ (TS _ 38)    }
  'i32'    { PT _ (TS _ 39)    }
  'i64'    { PT _ (TS _ 40)    }
  'i8'     { PT _ (TS _ 41)    }
  'if'     { PT _ (TS _ 42)    }
  'nil'    { PT _ (TS _ 43)    }
  'return' { PT _ (TS _ 44)    }
  'sizeof' { PT _ (TS _ 45)    }
  'struct' { PT _ (TS _ 46)    }
  'true'   { PT _ (TS _ 47)    }
  'u16'    { PT _ (TS _ 48)    }
  'u32'    { PT _ (TS _ 49)    }
  'u64'    { PT _ (TS _ 50)    }
  'u8'     { PT _ (TS _ 51)    }
  'union'  { PT _ (TS _ 52)    }
  'void'   { PT _ (TS _ 53)    }
  'while'  { PT _ (TS _ 54)    }
  '|'      { PT _ (TS _ 55)    }
  '||'     { PT _ (TS _ 56)    }
  '~'      { PT _ (TS _ 57)    }
  L_charac { PT _ (TC $$)      }
  L_doubl  { PT _ (TD $$)      }
  L_integ  { PT _ (TI $$)      }
  L_quoted { PT _ (TL $$)      }
  L_IDENT  { PT _ (T_IDENT $$) }

%%

Char    :: { Char }
Char     : L_charac { (read (Data.Text.unpack $1)) :: Char }

Double  :: { Double }
Double   : L_doubl  { (read (Data.Text.unpack $1)) :: Double }

Integer :: { Integer }
Integer  : L_integ  { (read (Data.Text.unpack $1)) :: Integer }

String  :: { String }
String   : L_quoted { (Data.Text.unpack $1) }

IDENT :: { Codegen.Pristinum.Abs.IDENT }
IDENT  : L_IDENT { Codegen.Pristinum.Abs.IDENT $1 }

Program :: { Codegen.Pristinum.Abs.Program }
Program : ListStmt { Codegen.Pristinum.Abs.PProgram $1 }

Stmt :: { Codegen.Pristinum.Abs.Stmt }
Stmt
  : Expr '.' { Codegen.Pristinum.Abs.SExpr $1 }
  | Bind ':=' Expr '.' { Codegen.Pristinum.Abs.SBind $1 $3 }
  | IDENT '=' Expr '.' { Codegen.Pristinum.Abs.SAssign $1 $3 }
  | 'if' Expr ':' ListStmt ListElifStmt 'end' { Codegen.Pristinum.Abs.SIf $2 $4 $5 }
  | 'if' Expr ':' ListStmt ListElifStmt 'else' ListStmt 'end' { Codegen.Pristinum.Abs.SIfElse $2 $4 $5 $7 }
  | 'while' Expr ':' ListStmt 'end' { Codegen.Pristinum.Abs.SWhile $2 $4 }
  | 'return' Expr '.' { Codegen.Pristinum.Abs.SReturn $2 }
  | 'return' '.' { Codegen.Pristinum.Abs.SReturnVoid }
  | 'func' IDENT '(' ListBind1 ')' '@' Type ':' ListStmt 'end' { Codegen.Pristinum.Abs.SFunction $2 $4 $7 $9 }
  | 'struct' IDENT ':' ListBind2 'end' { Codegen.Pristinum.Abs.SStruct $2 $4 }
  | 'union' IDENT ':' ListBind2 'end' { Codegen.Pristinum.Abs.SUnion $2 $4 }

ListStmt :: { [Codegen.Pristinum.Abs.Stmt] }
ListStmt : {- empty -} { [] } | Stmt ListStmt { (:) $1 $2 }

ElifStmt :: { Codegen.Pristinum.Abs.ElifStmt }
ElifStmt
  : 'elif' Expr ':' ListStmt { Codegen.Pristinum.Abs.ESElif $2 $4 }

ListElifStmt :: { [Codegen.Pristinum.Abs.ElifStmt] }
ListElifStmt
  : {- empty -} { [] } | ElifStmt ListElifStmt { (:) $1 $2 }

Expr :: { Codegen.Pristinum.Abs.Expr }
Expr
  : 'nil' { Codegen.Pristinum.Abs.ENil }
  | 'true' { Codegen.Pristinum.Abs.ETrue }
  | 'false' { Codegen.Pristinum.Abs.EFalse }
  | Char { Codegen.Pristinum.Abs.EChar $1 }
  | Integer { Codegen.Pristinum.Abs.EInt $1 }
  | Double { Codegen.Pristinum.Abs.EDouble $1 }
  | String { Codegen.Pristinum.Abs.EString $1 }
  | IDENT { Codegen.Pristinum.Abs.EIdent $1 }
  | IDENT '(' ListExpr ')' { Codegen.Pristinum.Abs.ECall $1 $3 }
  | 'sizeof' '(' Type ')' { Codegen.Pristinum.Abs.ESizeof $3 }
  | Expr '--' { Codegen.Pristinum.Abs.EDecr $1 }
  | Expr '++' { Codegen.Pristinum.Abs.EIncr $1 }
  | Expr '~' { Codegen.Pristinum.Abs.EBitNot $1 }
  | Expr '!' { Codegen.Pristinum.Abs.ENot $1 }
  | Expr Expr '+' { Codegen.Pristinum.Abs.EAdd $1 $2 }
  | Expr Expr '-' { Codegen.Pristinum.Abs.ESubtract $1 $2 }
  | Expr Expr '*' { Codegen.Pristinum.Abs.EMultiply $1 $2 }
  | Expr Expr '/' { Codegen.Pristinum.Abs.EDivide $1 $2 }
  | Expr Expr '%' { Codegen.Pristinum.Abs.EMod $1 $2 }
  | Expr Expr '**' { Codegen.Pristinum.Abs.EPower $1 $2 }
  | Expr Expr '<<' { Codegen.Pristinum.Abs.EBitShl $1 $2 }
  | Expr Expr '>>' { Codegen.Pristinum.Abs.EBitShr $1 $2 }
  | Expr Expr '&' { Codegen.Pristinum.Abs.EBitAnd $1 $2 }
  | Expr Expr '|' { Codegen.Pristinum.Abs.EBitOr $1 $2 }
  | Expr Expr '^' { Codegen.Pristinum.Abs.EBitXor $1 $2 }
  | Expr Expr '==' { Codegen.Pristinum.Abs.EEqual $1 $2 }
  | Expr Expr '!=' { Codegen.Pristinum.Abs.ENotEqual $1 $2 }
  | Expr Expr '<' { Codegen.Pristinum.Abs.ELess $1 $2 }
  | Expr Expr '>' { Codegen.Pristinum.Abs.EGreater $1 $2 }
  | Expr Expr '<=' { Codegen.Pristinum.Abs.ELessEqual $1 $2 }
  | Expr Expr '>=' { Codegen.Pristinum.Abs.EGreaterEqual $1 $2 }
  | Expr Expr '&&' { Codegen.Pristinum.Abs.EAnd $1 $2 }
  | Expr Expr '||' { Codegen.Pristinum.Abs.EOr $1 $2 }

ListExpr :: { [Codegen.Pristinum.Abs.Expr] }
ListExpr
  : {- empty -} { [] }
  | Expr { (:[]) $1 }
  | Expr ',' ListExpr { (:) $1 $3 }

Bind :: { Codegen.Pristinum.Abs.Bind }
Bind : IDENT '@' Type { Codegen.Pristinum.Abs.BBind $1 $3 }

Bind1 :: { Codegen.Pristinum.Abs.Bind }
Bind1 : Bind { $1 }

Bind2 :: { Codegen.Pristinum.Abs.Bind }
Bind2 : Bind { $1 }

ListBind1 :: { [Codegen.Pristinum.Abs.Bind] }
ListBind1
  : {- empty -} { [] }
  | Bind1 { (:[]) $1 }
  | Bind1 ',' ListBind1 { (:) $1 $3 }

ListBind2 :: { [Codegen.Pristinum.Abs.Bind] }
ListBind2
  : Bind2 '.' { (:[]) $1 } | Bind2 '.' ListBind2 { (:) $1 $3 }

Type :: { Codegen.Pristinum.Abs.Type }
Type
  : 'void' { Codegen.Pristinum.Abs.TVoid }
  | 'bool' { Codegen.Pristinum.Abs.TBool }
  | 'char' { Codegen.Pristinum.Abs.TChar }
  | 'i8' { Codegen.Pristinum.Abs.TInt8 }
  | 'i16' { Codegen.Pristinum.Abs.TInt16 }
  | 'i32' { Codegen.Pristinum.Abs.TInt32 }
  | 'i64' { Codegen.Pristinum.Abs.TInt64 }
  | 'u8' { Codegen.Pristinum.Abs.TUint8 }
  | 'u16' { Codegen.Pristinum.Abs.TUint16 }
  | 'u32' { Codegen.Pristinum.Abs.TUint32 }
  | 'u64' { Codegen.Pristinum.Abs.TUint64 }
  | 'f32' { Codegen.Pristinum.Abs.TFloat32 }
  | 'f64' { Codegen.Pristinum.Abs.TFloat64 }
  | Type '*' { Codegen.Pristinum.Abs.TPointer $1 }
  | 'struct' IDENT { Codegen.Pristinum.Abs.TStruct $2 }
  | 'union' IDENT { Codegen.Pristinum.Abs.TUnion $2 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: Data.Text.Text -> [Token]
myLexer = tokens

}

