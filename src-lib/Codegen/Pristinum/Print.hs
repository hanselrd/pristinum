-- File generated by the BNF Converter (bnfc 2.9.3).
{-# LANGUAGE CPP #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE LambdaCase #-}
#if __GLASGOW_HASKELL__ <= 708
{-# LANGUAGE OverlappingInstances #-}
#endif

-- | Pretty-printer for Codegen.
module Codegen.Pristinum.Print where

import qualified Codegen.Pristinum.Abs
import Data.Char (Char, isSpace)
import qualified Data.Text
import Prelude
  ( Bool (..),
    Double,
    Int,
    Integer,
    ShowS,
    String,
    all,
    elem,
    foldr,
    id,
    map,
    null,
    replicate,
    showChar,
    showString,
    shows,
    span,
    ($),
    (*),
    (+),
    (++),
    (-),
    (.),
    (<),
    (==),
  )

-- | The top-level printing method.
printTree :: Print a => a -> String
printTree = render . prt 0

type Doc = [ShowS] -> [ShowS]

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 False (map ($ "") $ d []) ""
  where
    rend ::
      Int ->
      Bool ->
      [String] ->
      ShowS
    rend i p = \case
      "[" : ts -> char '[' . rend i False ts
      "(" : ts -> char '(' . rend i False ts
      "{" : ts -> onNewLine i p . showChar '{' . new (i + 1) ts
      "}" : ";" : ts -> onNewLine (i - 1) p . showString "};" . new (i - 1) ts
      "}" : ts -> onNewLine (i - 1) p . showChar '}' . new (i - 1) ts
      [";"] -> char ';'
      ";" : ts -> char ';' . new i ts
      t : ts@(s : _)
        | closingOrPunctuation s ->
          pending . showString t . rend i False ts
      t : ts -> pending . space t . rend i False ts
      [] -> id
      where
        -- Output character after pending indentation.
        char :: Char -> ShowS
        char c = pending . showChar c

        -- Output pending indentation.
        pending :: ShowS
        pending = if p then indent i else id

    -- Indentation (spaces) for given indentation level.
    indent :: Int -> ShowS
    indent i = replicateS (2 * i) (showChar ' ')

    -- Continue rendering in new line with new indentation.
    new :: Int -> [String] -> ShowS
    new j ts = showChar '\n' . rend j True ts

    -- Make sure we are on a fresh line.
    onNewLine :: Int -> Bool -> ShowS
    onNewLine i p = (if p then id else showChar '\n') . indent i

    -- Separate given string from following text by a space (if needed).
    space :: String -> ShowS
    space t s =
      case (all isSpace t', null spc, null rest) of
        (True, _, True) -> [] -- remove trailing space
        (False, _, True) -> t' -- remove trailing space
        (False, True, False) -> t' ++ ' ' : s -- add space if none
        _ -> t' ++ s
      where
        t' = showString t []
        (spc, rest) = span isSpace s

    closingOrPunctuation :: String -> Bool
    closingOrPunctuation [c] = c `elem` closerOrPunct
    closingOrPunctuation _ = False

    closerOrPunct :: String
    closerOrPunct = ")],;"

parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')

concatS :: [ShowS] -> ShowS
concatS = foldr (.) id

concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

-- | The printer class does the job.
class Print a where
  prt :: Int -> a -> Doc

instance {-# OVERLAPPABLE #-} Print a => Print [a] where
  prt i = concatD . map (prt i)

instance Print Char where
  prt _ c = doc (showChar '\'' . mkEsc '\'' c . showChar '\'')

instance Print String where
  prt _ = printString

printString :: String -> Doc
printString s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q = \case
  s | s == q -> showChar '\\' . showChar s
  '\\' -> showString "\\\\"
  '\n' -> showString "\\n"
  '\t' -> showString "\\t"
  s -> showChar s

prPrec :: Int -> Int -> Doc -> Doc
prPrec i j = if j < i then parenth else id

instance Print Integer where
  prt _ x = doc (shows x)

instance Print Double where
  prt _ x = doc (shows x)

instance Print Codegen.Pristinum.Abs.IDENT where
  prt _ (Codegen.Pristinum.Abs.IDENT i) = doc $ showString (Data.Text.unpack i)

instance Print Codegen.Pristinum.Abs.Program where
  prt i = \case
    Codegen.Pristinum.Abs.PProgram stmts -> prPrec i 0 (concatD [prt 0 stmts])

instance Print Codegen.Pristinum.Abs.Stmt where
  prt i = \case
    Codegen.Pristinum.Abs.SExpr expr -> prPrec i 0 (concatD [prt 0 expr, doc (showString ".")])
    Codegen.Pristinum.Abs.SBind bind expr -> prPrec i 0 (concatD [prt 0 bind, doc (showString ":="), prt 0 expr, doc (showString ".")])
    Codegen.Pristinum.Abs.SAssign ident expr -> prPrec i 0 (concatD [prt 0 ident, doc (showString "="), prt 0 expr, doc (showString ".")])
    Codegen.Pristinum.Abs.SIf expr stmts elifstmts -> prPrec i 0 (concatD [doc (showString "if"), prt 0 expr, doc (showString ":"), prt 0 stmts, prt 0 elifstmts, doc (showString "end")])
    Codegen.Pristinum.Abs.SIfElse expr stmts1 elifstmts stmts2 -> prPrec i 0 (concatD [doc (showString "if"), prt 0 expr, doc (showString ":"), prt 0 stmts1, prt 0 elifstmts, doc (showString "else"), prt 0 stmts2, doc (showString "end")])
    Codegen.Pristinum.Abs.SWhile expr stmts -> prPrec i 0 (concatD [doc (showString "while"), prt 0 expr, doc (showString ":"), prt 0 stmts, doc (showString "end")])
    Codegen.Pristinum.Abs.SReturn expr -> prPrec i 0 (concatD [doc (showString "return"), prt 0 expr, doc (showString ".")])
    Codegen.Pristinum.Abs.SReturnVoid -> prPrec i 0 (concatD [doc (showString "return"), doc (showString ".")])
    Codegen.Pristinum.Abs.SFunction ident binds type_ stmts -> prPrec i 0 (concatD [doc (showString "func"), prt 0 ident, doc (showString "("), prt 1 binds, doc (showString ")"), doc (showString "@"), prt 0 type_, doc (showString ":"), prt 0 stmts, doc (showString "end")])
    Codegen.Pristinum.Abs.SStruct ident binds -> prPrec i 0 (concatD [doc (showString "struct"), prt 0 ident, doc (showString ":"), prt 2 binds, doc (showString "end")])
    Codegen.Pristinum.Abs.SUnion ident binds -> prPrec i 0 (concatD [doc (showString "union"), prt 0 ident, doc (showString ":"), prt 2 binds, doc (showString "end")])

instance Print [Codegen.Pristinum.Abs.Stmt] where
  prt _ [] = concatD []
  prt _ (x : xs) = concatD [prt 0 x, prt 0 xs]

instance Print Codegen.Pristinum.Abs.ElifStmt where
  prt i = \case
    Codegen.Pristinum.Abs.ESElif expr stmts -> prPrec i 0 (concatD [doc (showString "elif"), prt 0 expr, doc (showString ":"), prt 0 stmts])

instance Print [Codegen.Pristinum.Abs.ElifStmt] where
  prt _ [] = concatD []
  prt _ (x : xs) = concatD [prt 0 x, prt 0 xs]

instance Print Codegen.Pristinum.Abs.Expr where
  prt i = \case
    Codegen.Pristinum.Abs.ENil -> prPrec i 0 (concatD [doc (showString "nil")])
    Codegen.Pristinum.Abs.ETrue -> prPrec i 0 (concatD [doc (showString "true")])
    Codegen.Pristinum.Abs.EFalse -> prPrec i 0 (concatD [doc (showString "false")])
    Codegen.Pristinum.Abs.EChar c -> prPrec i 0 (concatD [prt 0 c])
    Codegen.Pristinum.Abs.EInt n -> prPrec i 0 (concatD [prt 0 n])
    Codegen.Pristinum.Abs.EDouble d -> prPrec i 0 (concatD [prt 0 d])
    Codegen.Pristinum.Abs.EString str -> prPrec i 0 (concatD [printString str])
    Codegen.Pristinum.Abs.EIdent ident -> prPrec i 0 (concatD [prt 0 ident])
    Codegen.Pristinum.Abs.ECall ident exprs -> prPrec i 0 (concatD [prt 0 ident, doc (showString "("), prt 0 exprs, doc (showString ")")])
    Codegen.Pristinum.Abs.ESizeof type_ -> prPrec i 0 (concatD [doc (showString "sizeof"), doc (showString "("), prt 0 type_, doc (showString ")")])
    Codegen.Pristinum.Abs.EDecr expr -> prPrec i 0 (concatD [prt 0 expr, doc (showString "--")])
    Codegen.Pristinum.Abs.EIncr expr -> prPrec i 0 (concatD [prt 0 expr, doc (showString "++")])
    Codegen.Pristinum.Abs.EBitNot expr -> prPrec i 0 (concatD [prt 0 expr, doc (showString "~")])
    Codegen.Pristinum.Abs.ENot expr -> prPrec i 0 (concatD [prt 0 expr, doc (showString "!")])
    Codegen.Pristinum.Abs.EAdd expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, prt 0 expr2, doc (showString "+")])
    Codegen.Pristinum.Abs.ESubtract expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, prt 0 expr2, doc (showString "-")])
    Codegen.Pristinum.Abs.EMultiply expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, prt 0 expr2, doc (showString "*")])
    Codegen.Pristinum.Abs.EDivide expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, prt 0 expr2, doc (showString "/")])
    Codegen.Pristinum.Abs.EMod expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, prt 0 expr2, doc (showString "%")])
    Codegen.Pristinum.Abs.EPower expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, prt 0 expr2, doc (showString "**")])
    Codegen.Pristinum.Abs.EBitShl expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, prt 0 expr2, doc (showString "<<")])
    Codegen.Pristinum.Abs.EBitShr expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, prt 0 expr2, doc (showString ">>")])
    Codegen.Pristinum.Abs.EBitAnd expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, prt 0 expr2, doc (showString "&")])
    Codegen.Pristinum.Abs.EBitOr expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, prt 0 expr2, doc (showString "|")])
    Codegen.Pristinum.Abs.EBitXor expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, prt 0 expr2, doc (showString "^")])
    Codegen.Pristinum.Abs.EEqual expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, prt 0 expr2, doc (showString "==")])
    Codegen.Pristinum.Abs.ENotEqual expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, prt 0 expr2, doc (showString "!=")])
    Codegen.Pristinum.Abs.ELess expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, prt 0 expr2, doc (showString "<")])
    Codegen.Pristinum.Abs.EGreater expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, prt 0 expr2, doc (showString ">")])
    Codegen.Pristinum.Abs.ELessEqual expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, prt 0 expr2, doc (showString "<=")])
    Codegen.Pristinum.Abs.EGreaterEqual expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, prt 0 expr2, doc (showString ">=")])
    Codegen.Pristinum.Abs.EAnd expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, prt 0 expr2, doc (showString "&&")])
    Codegen.Pristinum.Abs.EOr expr1 expr2 -> prPrec i 0 (concatD [prt 0 expr1, prt 0 expr2, doc (showString "||")])

instance Print [Codegen.Pristinum.Abs.Expr] where
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 0 x]
  prt _ (x : xs) = concatD [prt 0 x, doc (showString ","), prt 0 xs]

instance Print Codegen.Pristinum.Abs.Bind where
  prt i = \case
    Codegen.Pristinum.Abs.BBind ident type_ -> prPrec i 0 (concatD [prt 0 ident, doc (showString "@"), prt 0 type_])

instance Print [Codegen.Pristinum.Abs.Bind] where
  prt 2 [x] = concatD [prt 2 x, doc (showString ".")]
  prt 2 (x : xs) = concatD [prt 2 x, doc (showString "."), prt 2 xs]
  prt _ [] = concatD []
  prt _ [x] = concatD [prt 1 x]
  prt _ (x : xs) = concatD [prt 1 x, doc (showString ","), prt 1 xs]

instance Print Codegen.Pristinum.Abs.Type where
  prt i = \case
    Codegen.Pristinum.Abs.TVoid -> prPrec i 0 (concatD [doc (showString "void")])
    Codegen.Pristinum.Abs.TBool -> prPrec i 0 (concatD [doc (showString "bool")])
    Codegen.Pristinum.Abs.TChar -> prPrec i 0 (concatD [doc (showString "char")])
    Codegen.Pristinum.Abs.TInt8 -> prPrec i 0 (concatD [doc (showString "i8")])
    Codegen.Pristinum.Abs.TInt16 -> prPrec i 0 (concatD [doc (showString "i16")])
    Codegen.Pristinum.Abs.TInt32 -> prPrec i 0 (concatD [doc (showString "i32")])
    Codegen.Pristinum.Abs.TInt64 -> prPrec i 0 (concatD [doc (showString "i64")])
    Codegen.Pristinum.Abs.TUint8 -> prPrec i 0 (concatD [doc (showString "u8")])
    Codegen.Pristinum.Abs.TUint16 -> prPrec i 0 (concatD [doc (showString "u16")])
    Codegen.Pristinum.Abs.TUint32 -> prPrec i 0 (concatD [doc (showString "u32")])
    Codegen.Pristinum.Abs.TUint64 -> prPrec i 0 (concatD [doc (showString "u64")])
    Codegen.Pristinum.Abs.TFloat32 -> prPrec i 0 (concatD [doc (showString "f32")])
    Codegen.Pristinum.Abs.TFloat64 -> prPrec i 0 (concatD [doc (showString "f64")])
    Codegen.Pristinum.Abs.TPointer type_ -> prPrec i 0 (concatD [prt 0 type_, doc (showString "*")])
    Codegen.Pristinum.Abs.TStruct ident -> prPrec i 0 (concatD [doc (showString "struct"), prt 0 ident])
    Codegen.Pristinum.Abs.TUnion ident -> prPrec i 0 (concatD [doc (showString "union"), prt 0 ident])
